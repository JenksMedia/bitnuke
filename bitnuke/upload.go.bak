package main

import (
	"bufio"
	"crypto/md5"
	"encoding/base64"
	"fmt"
	"html/template"
	"io"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/unixvoid/glogger"
	"golang.org/x/crypto/sha3"
	"gopkg.in/redis.v3"
)

func upload(w http.ResponseWriter, r *http.Request, client *redis.Client, state string) {
	/*
		    three things happen here. after the fileId, secretKey, and removalKey are generated
				the following fields are made and uploaded to redis (AFTER encryption).

				note that 4b7fb8096e6413f0d0ac246dfbc11a86<SNIP> is the sha3:512 hashed value of the
				  key 'c4b08d47a0'.
				note the contents of these redis keys are encrypted

				4b7fb8096e6413f0d0ac246dfbc11a86<SNIP>       : file contents
				meta:4b7fb8096e6413f0d0ac246dfbc11a86<SNIP>  : meta for the key (delete key)
	*/

	// get file POST from index
	if r.Method == "GET" {
		crutime := time.Now().Unix()
		h := md5.New()
		io.WriteString(h, strconv.FormatInt(crutime, 10))
		token := fmt.Sprintf("%x", h.Sum(nil))
		t, _ := template.ParseFiles("upload.gtpl")
		t.Execute(w, token)
	} else {
		r.ParseMultipartForm(32 << 20)

		// set default filename
		filename := "unnamed_file"

		file, multipartFileHeader, err := r.FormFile("file")
		if err != nil {
			glogger.Error.Println(err)
			return
		} else {
			// overwrite default filename with parsed filename
			rawFilename := fmt.Sprintf("%v", multipartFileHeader.Filename)
			filename = rawFilename
		}
		defer file.Close()

		// generate token and hash to save
		token := tokenGen(config.Bitnuke.TokenSize, client)
		println("token: ", token)
		hash := sha3.Sum512([]byte(token))
		hashstr := fmt.Sprintf("%x", hash)

		// generate encryption token for accessing content
		secToken := secTokenGen(hashstr, client)

		// generate removal token for removing content
		delToken := tokenGen(config.Bitnuke.DelTokenSize, client)

		// set client headers
		w.Header().Set("file_id", token)
		w.Header().Set("sec_key", secToken)
		w.Header().Set("removal_key", delToken)
		fmt.Fprintf(w, "%s", token)

		glogger.Debug.Println("file id:       ", token)
		glogger.Debug.Println("secret key:    ", secToken)
		glogger.Debug.Println("delete token:  ", delToken)

		// get sha3:512 of token

		// done with client, store info in redis
		glogger.Debug.Println("uploading:", token)
		// write file temporarily to get filesize
		f, _ := os.OpenFile("tmpfile", os.O_WRONLY|os.O_CREATE, 0666)
		defer f.Close()
		io.Copy(f, file)
		tmpFile, _ := os.Open("tmpfile")
		defer tmpFile.Close()
		fInfo, _ := tmpFile.Stat()
		var size int64 = fInfo.Size()
		buf := make([]byte, size)

		// read file content into buffer
		fReader := bufio.NewReader(tmpFile)
		fReader.Read(buf)
		fileBase64Str := base64.StdEncoding.EncodeToString(buf)

		client.Set(hashstr, fileBase64Str, 0).Err()
		client.Set(fmt.Sprintf("fname:%s", hashstr), filename, 0).Err()
		if strings.EqualFold(state, "tmp") {
			// expire if not coming from /supload
			client.Expire(hashstr, (config.Bitnuke.TTL * time.Hour)).Err()
			client.Expire(fmt.Sprintf("sec:%s", hashstr), (config.Bitnuke.TTL * time.Hour)).Err()
			client.Expire(fmt.Sprintf("filename:%s", hashstr), (config.Bitnuke.TTL * time.Hour)).Err()
			glogger.Debug.Println("expire link generated")
		}
		os.Remove("tmpfile")
	}
}
